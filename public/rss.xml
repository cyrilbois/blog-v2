
  <rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:media="http://search.yahoo.com/mrss/">
    <channel>
      <title>MJ Kim</title>
      <link>https://howdy-blog-v2.vercel.app</link>
      <description>안녕하세요, 기록하고 공유하기를 좋아하는 프론트엔드 개발자 김민정입니다.</description>
      <language>ko</language>
      <managingEditor>hi.minjungkim@gmail.com (MJ Kim)</managingEditor>
      <webMaster>hi.minjungkim@gmail.com (MJ Kim)</webMaster>
      <lastBuildDate>Sun, 25 Sep 2022 00:00:00 GMT</lastBuildDate>
      <atom:link href="https://howdy-blog-v2.vercel.app/rss.xml" rel="self" type="application/rss+xml"/>
      
    <item>
      <guid>https://howdy-blog-v2.vercel.app/react/useEffect-and-useLayoutEffect</guid>
      <title>useEffect와 useLayoutEffect의 차이</title>
      <link>https://howdy-blog-v2.vercel.app/react/useEffect-and-useLayoutEffect</link>
      undefined
      <pubDate>Sun, 25 Sep 2022 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>react</category>
      <content:encoded>
예전에 데이터에 따라 DOM 조작이 필요했었는데, 이때 화면의 깜빡임을 없애기 위해 useEffect 대신 useLayoutEffect를 사용했었다.

그러나 정확히 이 둘의 차이가 무엇인지 생각해보면, 대답할 수 없었다.

## useEffect

React의 render phase에 따르면, 변형(mutations), 구독(subscriptions), 타이머, 로깅 등의 사이드 이펙트들이 컴포넌트 함수 내부에 있어서는 안된다. _(추후 다른 글로 작성할 예정)_

이를 해결하기 위해 useEffect를 사용하는데, [useEffect](https://reactjs.org/docs/hooks-reference.html#useeffect)는 화면 렌더링이 완료된 후 혹은 어떤 값이 변경되었을 때 사이드 이펙트를 수행한다.

### 실행 시점

useEffect로 전달된 함수는 layout과 paint가 완료된 후에 **비동기적**으로 실행된다.

이때 만약 DOM에 영향을 주는 코드가 있을 경우, 사용자는 화면의 깜빡임과 동시에 화면 내용이 달라지는 것을 볼 수 있다. 중요한 정보일 경우, 화면이 다 렌더되기 전에 동기화해주는 것이 좋은데, 이를 위해 useLayoutEffect라는 훅이 나왔으며, 기능은 동일하되 실행 시점만 다르다.

React 18부터는 useEffect에서도 layout과 paint 전에 동기적으로 함수를 실행할 수 있는 [flushSync](https://reactjs.org/docs/react-dom.html#flushsync)라는 함수가 추가되었다. 하지만 강제로 실행하는 것이다보니, 성능상 이슈가 있을 수 있다.

## useLayoutEffect

[useLayoutEffect](https://ko.reactjs.org/docs/hooks-reference.html#uselayouteffect)는 useEffect와 동일하지만, 렌더링 후 layout과 paint 전에 **동기적**으로 실행된다.

때문에 설령 DOM을 조작하는 코드가 존재하더라도, 사용자는 깜빡임을 보지 않는다.

### 예제

간단하게 DOM을 조작하는 코드를 만들었다.



버튼 클릭 시, 버튼의 bottom을 가져와 텍스트가 위치할 top을 계산하여 화면에 보여주는 것으로, useEffct로 하느냐 useLayoutEffect로 하느냐의 차이만 존재한다.

그런데 너무 빨라서 두 개의 차이를 잘 보지 못할 수 있는데, 클릭한 것을 0.25배속하여 만들어보았다.


  
  0.25배속이기 때문에 인내심을 요한다


사실 0.25배속으로 해도 두 개의 차이가 크게 나타나지 않는다. 찰나의 순간 깜빡임이 있느냐 없느냐의 차이다.

따라서 스크롤 위치를 찾거나 어떤 element의 스타일 요소를 변경하는 등 직접적으로 DOM을 조작하는 곳 제외하고는 useEffect를 사용하는 것을 추천한다. 공식 문서에서도 useEffect를 먼저 사용한 후에, 문제가 생긴다면 그때 useLayoutEffect를 사용하는 것을 추천하고 있다.

### 서버 렌더링에서 useLayoutEffect 사용하기

Next.js와 같은 서버 렌더링을 사용하는 경우, 자바스크립트가 모두 다운로드 될 때까지 useEffect와 useLayoutEffect 그 어느 것도 실행되지 않는다. 따라서 서버에서 렌더링되는 컴포넌트에서 useLayoutEffect를 사용하는 경우, React에서 경고를 띄운다.

```txt
Warning: useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See  for common fixes.
```

useLayoutEffect는 페인트 전에 실행되기 때문에 서버에서 렌더되는 화면과 클라이언트에서 렌더되는 화면이 다를 수 있다. 따라서 useLayoutEffect는 오직 클라이언트 사이드에서만 실행되어야 한다는 경고 메세지다.



위 에러에서 알려주는 링크를 따라가보면 [uselayouteffect-ssr.md](https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85)에 따르면, 두 가지 방법을 알려준다.

첫 번째는 useEffect 사용하는 방법이다.

```js
function MyComponent() {
  useEffect(() => {
    // ...
  });
}
```

두 번째는 해당 컴포넌트를 lazy하게 로드하는 방법이다.

```js
function Parent() {
  const [showChild, setShowChild] = useState(false);

  // 클라이언트 사이드의 hydration 이후에 보여주기
  useEffect(() => {
    setShowChild(true);
  }, []);

  if (!showChild) {
    return null;
  }

  return ;
}

function Child(props) {
  useLayoutEffect(() => {
    // ...
  });
}
```

이 외에 세 번째 방법으로는 [useIsomorphicLayoutEffect](https://usehooks-ts.com/react-hook/use-isomorphic-layout-effect) 훅을 사용할 수 있다.

```js
import { useEffect, useLayoutEffect } from 'react';

const useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;

export default useIsomorphicLayoutEffect;
```

서버일 경우 useLayoutEffect를 useEffect로 변경헌다.

## 코드로 알아보기

그렇다면 코드상으로는 어떤 부분이 다를까?

```js:ReactHooks.js
export function useEffect(
  create: () => (() => void) | void,
  deps: Array | void | null
): void {
  const dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}

export function useLayoutEffect(
  create: () => (() => void) | void,
  deps: Array | void | null
): void {
  const dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, deps);
}
```

[useEffect](https://github.com/facebook/react/blob/cb5084d1c4dc0693e7dcd8af7e921a0aa771914b/packages/react/src/ReactHooks.js#L102)와 [useLayoutEffect](https://github.com/facebook/react/blob/cb5084d1c4dc0693e7dcd8af7e921a0aa771914b/packages/react/src/ReactHooks.js#L118)는 실행 시점만 다를 뿐 같은 로직이기 때문에 코드만 봤을 때는 차이가 없다.



다음에는 어떤 코드를 봐야할까 고민 하던 중, react-reconciler의 [Dispatcher](https://github.com/facebook/react/blob/cb5084d1c4dc0693e7dcd8af7e921a0aa771914b/packages/react-reconciler/src/ReactInternalTypes.js#L363)를 봤지만, 타입만 명시해줄 뿐 특별히 다른건 없었다.

그러다 해당 파일 상단에 HookType이 `ReactFiberHooks.old.js`로 이동했다는 주석을 보고 동일 계층의 파일들을 보니 `ReactFiberHooks.new.js`도 있어서 해당 파일을 보기로 했다.

```js:ReactFiberHooks.new.js
const HooksDispatcherOnMount: Dispatcher = {
  // ...생략
  useEffect: mountEffect,
  useLayoutEffect: mountLayoutEffect,
};

const HooksDispatcherOnUpdate: Dispatcher = {
  // ...생략
  useEffect: updateEffect,
  useLayoutEffect: updateLayoutEffect,
};

const HooksDispatcherOnRerender: Dispatcher = {
  // ...생략
  useEffect: updateEffect,
  useLayoutEffect: updateLayoutEffect,
};
```

다른 점을 찾았다.

useEffect는 mountEffect와 updateEffect를, useLayoutEffect는 mountLayoutEffect와 updateLayoutEffect를 실행한다. mount와 update 함수의 구조는 거의 비슷하여
해당 글에서는 mount만 다룬다.

```js:ReactFiberHooks.new.js {3, 11-12}
// useEffect
function mountEffect(create: () => (() => void) | void, deps: Array | void | null): void {
  return mountEffectImpl(PassiveEffect | PassiveStaticEffect, HookPassive, create, deps);
}

// useLayoutEffect
function mountLayoutEffect(
  create: () => (() => void) | void,
  deps: Array | void | null
): void {
  const fiberFlags: Flags = UpdateEffect | LayoutStaticEffect;
  return mountEffectImpl(fiberFlags, HookLayout, create, deps);
}
```

그리고 이 둘의 차이는 return하는 함수의 첫 번째(fiberFlags), 두 번째(hookFlags) 인자가 달랐다.

```js:ReactFiberHooks.new.js {5}
function mountEffectImpl(fiberFlags, hookFlags, create, deps: Array | void | null): void {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, undefined, nextDeps);
}
```

[FiberFlags](https://github.com/facebook/react/blob/cb5084d1c4dc0693e7dcd8af7e921a0aa771914b/packages/react-reconciler/src/ReactFiberFlags.js)

```js:ReactFiberFlags.js
export type Flags = number;

export const Update = /*                       */ 0b000000000000000000000100; // => UpdateEffect
export const Passive = /*                      */ 0b000000000000010000000000; // => PassiveEffect

export const LayoutStatic = /*                 */ 0b001000000000000000000000; // => LayoutStaticEffect
export const PassiveStatic = /*                */ 0b010000000000000000000000; // => PassivStaticEffect
```

[HookFlags](https://github.com/facebook/react/blob/cb5084d1c4dc0693e7dcd8af7e921a0aa771914b/packages/react-reconciler/src/ReactHookEffectTags.js)

```js:ReactHookEffectTags.js
export type HookFlags = number;

export const Layout = /*    */ 0b01000; // => HookLayout
export const Passive = /*   */ 0b10000; // => HookPassive
```

그리고 이 fiberFlags와 hookFlags는 pushEffect 함수의 첫 번째 인자인 tag로 들어가고, 해당 함수는 `componentUpdateQueue`로 업데이트 할 컴포넌트를 Flag를 통해 Queue로 관리하는 것 같다.

```js:ReactFiberHooks.new.js {10-11}
function pushEffect(tag, create, destroy, deps: Array | void | null) {
  const effect: Effect = {
    tag,
    create,
    destroy,
    deps,
    // Circular
    next: (null: any),
  };
  let componentUpdateQueue: null | FunctionComponentUpdateQueue =
    (currentlyRenderingFiber.updateQueue: any);
  if (componentUpdateQueue === null) {
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber.updateQueue = (componentUpdateQueue: any);
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    const lastEffect = componentUpdateQueue.lastEffect;
    if (lastEffect === null) {
      componentUpdateQueue.lastEffect = effect.next = effect;
    } else {
      const firstEffect = lastEffect.next;
      lastEffect.next = effect;
      effect.next = firstEffect;
      componentUpdateQueue.lastEffect = effect;
    }
  }
  return effect;
}
```

그리고 초기값으로 할당된 currentlyRenderingFiber는 renderWithHooks 함수에서 현재 동작중인 훅을 기록하는 것으로 보인다.

```js:ReactFiberHooks.new.js {10}
export function renderWithHooks(
  current: Fiber | null,
  workInProgress: Fiber,
  Component: (p: Props, arg: SecondArg) => any,
  props: Props,
  secondArg: SecondArg,
  nextRenderLanes: Lanes,
): any {
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber = workInProgress;
}
```

## 결론

useEffect와 useLayoutEffect가 어떻게 다르고, 어떤 코드로 이루어졌는지 알아보았다.

그런데 사실 어떤 원리로 동작하는지 정확하게 파악하려면, React의 Fiber 알고리즘과 Reconciliation까지 이해해야 정확한 글을 작성할 수 있을 것 같다. (결국 수박 겉핥기 글이 되어버렸다..)





**참고**

- [React](https://reactjs.org/)


</content:encoded>
    </item>
  
    <item>
      <guid>https://howdy-blog-v2.vercel.app/mj-log/howdy-nextjs-starter</guid>
      <title>블로그 구축기</title>
      <link>https://howdy-blog-v2.vercel.app/mj-log/howdy-nextjs-starter</link>
      <description>한 달 간 블로그 템플릿 만든 후기</description>
      <pubDate>Mon, 12 Sep 2022 00:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>mj.log</category>
      <content:encoded>
## 블로그를 만든 이유

왜인지는 모르겠지만, 어렸을 때부터 블로그를 썼었다. 그때는 즐겨하던 게임 공략을 네이버 블로그에 작성했었다. 방문자 수가 올라가던 걸 보면서 글을 더 잘 쓰고, 사람들이 찾고 싶어 하는 내용을 작성하고 싶다는 생각이 강했다.

그다음에는 개발자 이전에 취준할 때 공부한 내용을 티스토리에 정리했었고, 개발자로 전향 후에는 JBee님이 만들어주신 [gatsby-starter-bee](https://github.com/JaeYeopHan/gatsby-starter-bee)로 블로그를 만들었다.

그러다 보니 알게 모르게 '나도 언젠가는 나만의 블로그를 만들어야지'라는 목표가 생겼고, 이번에 드디어 이루었다.

### 구축 기간

사실 예전에도 블로그 만들기를 여러 번 시도했었다. 티스토리를 사용할 때는 워드프레스로 시도했으나 결국 실패했고, 작년에는 프로젝트 초기 세팅만 하다가 어떻게 만들어야 할까만 고민하다 삭제했었다.

이는 모두 내가 어떤 블로그를 원하는지에 대한 생각이 불충분했다고 판단했다. 그래서 사용했던 블로그들의 좋았던 점들이나 아쉬웠던 점들, 평소에 봤던 페이지 중에서 내가 좋아하는 포인트들을 수시로 메모했다.

그 덕분인지, 한 달가량 작업했더니 완성할 수 있었다.

그렇다고 여유롭진 않았다. 퇴근하고 작업하니 피곤한 적도 많았고, 8월은 유독 약속이 많았던 달이었다. 그리고 무엇보다 올해 런칭해야 하는 프로젝트가 생겨서, 블로그는 무조건 이번 추석에 배포해야겠다는 생각이 들어서, 어떻게 보면 반강제적으로 한 달이라는 시간이 주어졌다.

### 기술 스택 선정 이유

해당 블로그는 Next.js, styled-components, next-mdx-remote를 사용했다.

블로그 구축할 때 Jekyll나 Gatsby를 많이 사용하는 거로 알고 있다. 그러나 필자는 현업에서 대부분 React, Next.js를 사용해왔고, 이 기술들이 이제는 어느 정도 안정기(?)가 아닐까 하는 생각을 감히 했다. 그리고 아직 현업에서 Next.js로 SEO를 처음부터 끝까지 해본 적이 없어서 도전해보고 싶었다.

스타일의 경우, 개인적으로 CSS 모듈보다 CSS-in-JS를 더 선호해서 주저없이 styled-components를 사용했다. 하지만 다크모드 구축할 때의 불편함을 미리 알았더라면 CSS 모듈도 고려했을 것 같다.

`mdx` 관련 라이브러리를 고를 때 고민을 많이 했다. 결국 유명한 라이브러리를 하나하나 사용해보면서 가장 편했던 것을 골랐다. `next-mdx-remote`가 작년까지는 mdx v1만 지원했지만, 올해 2월에 v2를 지원하면서부터 딱히 불편한 점은 없었다.

## 어려웠던 점

### 디자인

가장 어려웠던 것은 바로 디자인이다.

가령 가로 폭을 어느 정도로 잡을지, 어느 테마에서든 오래 봐도 눈이 피로하지 않은 색상으로 만들고 싶었다. 기본 텍스트 색상 외에 다른 어떤 색상이 눈에 잘 보이면서도 이질감이 없을지 등등, 가장 많은 고민과 시간을 투자했다.

초반에는 색상을 여러 개 추가했다가, 거의 다 제거하고 최대한 단순화했다. 그래서 지금은 약간 밋밋한 느낌도 없잖아 있다.

특히 다크모드를 구현할 때 이에 매칭되는 색상이 어떤 걸로 정할지 고민을 엄청나게 했다. Color Contrast 사이트를 사용했지만, 이상하게 점수가 높은 색상을 적용하면 폰트 색상이 묻히거나 배경 색상이 이상해져서, 최대한 중간 타협점을 찾아서 수정했다. 물론 내 눈에만 이상했던 걸 수도 있지만.. 나중에 더 좋은 색상을 찾으면 바꿀 것 같다.

어느 정도 틀이 잡힌 후에 회사 디자이너분에게 간단한 피드백을 요청드렸고, 덕분에 훨씬 좋아진 것 같다. _(그렇지만 그때 말씀해주신 건 다 적용 못 했어요.. 나중에 천천히 할게요...ㅠㅠ)_

### md와 mdx

필자는 `md`와 `mdx`를 모두 사용할 수 있게 만들고 싶었다.

`md`는 이전 블로그를 `md`로 작성한 이유가 (가장) 컸지만, 블로그를 작성하는 대부분의 사람은 다른 곳에서 마크다운으로 작성한 문서를 그대로 복붙해서 가져오고 있는 것 같아서 유지하기로 했다.

하지만 JSX 문법으로 작성할 수 있는 `mdx`의 유혹도 상당했다. JSX 문법을 활용한다면 나중에 더 다양한 컴포넌트를 추가할 수 있기 때문에 절대 놓치고 싶지 않았다. 특히 작성한 코드 블럭을 보여주기 위해 code sandbox나 codepen에 작성한 후 그걸 iframe으로 가져 왔었는데, 너무 불편해서 어떻게든 줄이고 싶었다. 나중에는 이러한 playground 컴포넌트를 만들어서 템플릿에 내제화하고 싶다.

무튼 이 두 개의 확장자를 모두 지원하고 싶다보니 파일을 불러올때 어떤 확장자인지 판별하는 구문이나, format 해주는 곳 등 신경써야 하는 곳이 많았다. `mdx-bundler`는 이상하게 `md` 파일인지 인지하지 못해서 열지 못하는 문제가 있었다. 물론 `next-mdx-remote`도 불편하진 않지만, 다른 라이브러리들을 완벽하게 사용해보지 못해서 아쉽다.

### Code block

개발 블로그이기 때문에 code block에 신경을 많이 썼다.

처음에는 [React Syntax Highlighter](https://github.com/react-syntax-highlighter/react-syntax-highlighter)를 사용했었다.

그런데 특정 줄을 하이라이팅하는 기능과 `이렇게 작성한 코드`와 code block을 구분하는 로직을 짤 때 '이게 맞나?' 싶을 정도로 조잡해졌었는데, 설상가상 내가 원하던 기능이 없었다.

가장 큰 이유는 해당 코드 블럭의 제목을 넣어줄 수 없다는 점이다. 이전 블로그에서는 해당 코드의 파일명이나 위치를 표기해주기 위해 코드 블럭 상단에 span 태그로 작성해주었는데, 이게 생각보다 귀찮았다. 특히 코드가 많이 나오는 곳에서는 더더욱 그랬다.

````
// 예전 방식
_app.tsx

```tsx
// ... 생략
```
````

두 번째로는 코드를 복사 & 붙여넣기 하는 기능을 원했다.

\
&nbsp;

그래서 그냥 remark, rehype로 다시 구축하기로 결심했다.

remark는 markdown을 변환해주는 플러그인이고, rehype는 HTML을 변환해주는 플러그인이다. 전체 플러그인은 [remark/plugins](https://github.com/remarkjs/remark/blob/main/doc/plugins.md), [rehype/plugins](https://github.com/rehypejs/rehype/blob/main/doc/plugins.md)에서 확인할 수 있다.

\
&nbsp;

그리하여 아래처럼 원하는 모양을 만들 수 있었다.

```js:hello.js {3-5}
const name = 'MJ Kim';

const helloThere = (name) => {
  return `Howdy, ${name}`;
};

helloThere(name);
```

_그런데 제목 부분 눈에 잘 띄지 않는 것 같아 수정해야겠다..._

### 다크모드

사실 이번에 다크모드까지 작업할 생각은 없었다. 그러다 점점 내가 목표했던 배포일이 다가오자, 이왕 배포할 거 같이 하자는 욕심이 들어서 급하게 추가했다.

그런데 styled-component의 ThemeProvider로 다크모드를 판단하자니, 처음에 라이트모드였다가 다크모드로 변경되는 그 1초가 너무 보기 싫었다. 그러한 유저 경험을 주는 블로그라면 내가 생각해도 싫을 것 같았다.

이런 저런 방법을 강구하다 결국 CSS variable을 선택했다. 이럴 줄 알았다면 처음에 CSS 모듈을 생각했을 텐데.. 역시 해보지 않으면 모르는 구나를 다시 한번 깨달았다. 다행히 이때 색상을 거의 통일해놔서 변경할 부분은 많지 않았다.

그리고 다크모드 구현이 끝난 줄 알았지만, utterances(댓글 컴포넌트)의 테마가 같이 변경되지 않았다. 여기저기 레퍼런스를 찾아봤지만 원하던 결과가 나오지 않아, 결국 테마를 토글할 때 utterances의 색상을 변경하는 로직을 넣어주었다. 이 부분도 수정하고 싶다. (utterances는 Github Repo가 public이어야 사용 가능해서 당분간은 사용 안할 예정이다)

### SEO

역시 생각처럼 쉽지 않았다. 그리고 OG Tag는 배포한 후에야 여러 플랫폼에서 결과가 제대로 나오는지 확인할 수 있었기 때문에 꽤나 번거로웠다.

그리고 글의 description에 어떤 내용을 보여줄지 summary의 유무에 따른 경우의 수 등을 생각하다보니 수정해야 할 곳이 많았다. 그리고 icon이 안나왔던 문제도 있어서 여러 메타 태그들을 찾아봤었다.

| ![블로그 페이지](https://user-images.githubusercontent.com/58619071/189531156-191812d6-8491-4901-ac54-56c14481db2d.png) |
| :---------------------------------------------------------------------------------------------------------------------: |
|                                                  블로그 페이지 테스트                                                   |

| ![글 시도1](https://user-images.githubusercontent.com/58619071/189531145-4e5632bc-0452-4dc5-ab58-41ce27752354.png) |
| :----------------------------------------------------------------------------------------------------------------: |
|                                                     글 시도 1                                                      |

| ![글 시도2](https://user-images.githubusercontent.com/58619071/189531154-7e9571c8-bb14-44a1-ada4-ec6dc50246e9.png) |
| :----------------------------------------------------------------------------------------------------------------: |
|                                                     글 시도 2                                                      |

### 커스텀 컴포넌트

이것도 어찌 보면 디자인과 연결되어 있는데, 컨텐츠의 요소들의 스타일 오버라이딩을 해주고 싶은 것들을 모두 컴포넌트로 만들었다.

그중에서도 텍스트들의 행간과 크기를 정하는 것이 가장 어려웠다. 텍스트들이 가장 많은 페이지인데, 어떻게 하면 덜 답답하고 글이 잘 읽히게 스타일링 할 수 있을까.. 여전히 진행중인 고민이다.

## 예상치 못했던 문제

위의 문제들을 어느 정도 해결하고 나니 이제 배포해도 되겠다는 생각이 들었다.

그래서 이전의 글을 새로운 블로그 Repo로 옮겨왔더니, 예상하지 못한 문제가 발생했다.

### 마크다운이 다 해주는 게 아니었다

필자가 자주 사용했던 마크다운에서는 모두 HTML 태그들을 사용해서 마크다운 단에서 지원해주는 기능인 줄 알았다.

하지만 알고 보니 마크다운은 특정 형식들만 인식해서 이를 파싱해줄 뿐, 그 외의 것들은 모두 변환하는 작업이 필요했다. 역시 당연한 것은 없었다.

왜 블로그를 만들 때 Gatsby를 사용하는지도 이때 알았다. 지원해주는 플러그인이 아주 많다. 살짝 후회하긴 했다..

\
&nbsp;

아직 원하는 기능을 모두 추가하지 못했다. 하지만 올해 배포를 못 하면 또 영영 못할 것만 같은 느낌이 들어서 우선 만든 부분까지만 배포하기로 했다. 이 때문에 아직 도메인도 옮기지 못했고, 이전 글들도 옮겨오지 못했다..🥲

전반적으로 remark, rehype 부분은 조금 더 깊게 공부하고 수정해야 할 것 같다.

### 템플릿 공개 연기

원래 howdy-nextjs-starter라는 템플릿으로 오픈하려고 했었다. 무리하게 일정을 잡은 것도 템플릿 공개 때문이었다.

그런데 첫 글을 작성하고 있는 지금, 자잘한 버그들과 부족한 부분 그리고 수정이 필요한 부분들이 너무 많다. 올해는 혼자 사용해보면서 보완 및 수정하고, 올해 말이나 내년 초쯤에 public으로 돌려놓을 예정이다.

아직 버전 `0.1.0`인데 올해 말에 `1.0.0`이 되길 기대해본다.

### 그 외...

분명 로컬에서 할 때는 잘 나왔는데, 배포하고 확인해보니 이상하게 보이는 곳들이 종종 보였다.

만약 블로그를 구축하시는 분이 계신다면 중간중간 배포해서 빌드된 결과물이 로컬과 동일하게 나오는지 확인하는 걸 추천한다.

## 마무리

구축한 한 달 동안 힘들었지만, 늘 생각해오던 목표 중 하나를 이루어서 무척이나 보람찼다.

아직 많이 부족해서 템플릿으로 공개는 못 했지만, 빠른 시일 내에 공개할 수 있도록 열심히 다듬어야겠다.

_(하나 아쉬운 점이 있다면, Gatsby로 만든 블로그의 SEO가 정말 잘 되고 있어서 갈아타기 무척이나 아쉽다.)_
</content:encoded>
    </item>
  
    <item>
      <guid>https://howdy-blog-v2.vercel.app/angular/angular-structure</guid>
      <title>Angular 파일 구조 소개</title>
      <link>https://howdy-blog-v2.vercel.app/angular/angular-structure</link>
      undefined
      <pubDate>Tue, 18 May 2021 15:00:00 GMT</pubDate>
      <author>hi.minjungkim@gmail.com (MJ Kim)</author>
      <category>angular</category>
      <content:encoded>
최근 Angular 대비 상대적으로 러닝커브가 낮고 사용하기 편한 React, Vue, Svelte 등이 나오면서 Angular의 사용률이 전체적으로 낮아지고 있는 추세다. [(참고)](https://2020.stateofjs.com/en-US/technologies/front-end-frameworks/)

필자도 React만 사용해보다 처음으로 Angular를 사용해봤는데, 확실히 러닝커브가 높은 편이지만 그만큼 매력적인 면도 많다고 생각한다. 본 글에서는 Angular의 특징이나 원칙 등의 원론적인 내용은 제외하고 사용할 때 꼭 알아야 할 내용을 다룬다.

## Angular 설치

```shell
# Angular CLI 설치
$ npm install -g @angular/cli

# Angular 프로젝트 생성
# 본 글에서는 angular routing을 설치했으며, scss를 선택했다
$ ng new 
$ cd 
```

> 본 글에서 @angular/core는 `~11.2.12`, rxjs는 `~6.6.0`, typescript는 `~4.1.5` 버전을 사용했다.

```shell
# 로컬에서 실행 및 창 열기
$ ng serve --open
```


  


잘 실행되었다면, `http://localhost:4200/`에 위와 같은 화면이 보인다.

실행 포트를 바꾸고 싶다면,

```shell
$ ng serve --open --port 4300
```

위 처럼 실행하면 된다.

폴더의 기본 구조는 아래와 같으며, 본 글에서는 `/src/app` 폴더 안에서 필수적으로 알아야 할 것들 위주로 다룬다.


  
    폴더 구조


## Angular 구조

Angular에는 크게 Component(컴포넌트), Template(템플릿), Directive(디렉티브), Service(서비스) 그리고 Module(모듈)이 존재한다.


  
    https://www.ngdevelop.tech/angular/architecture/


Angular 프로젝트를 생성하면 기본으로 만들어지는 모듈과 컴포넌트가 있다. 모듈은 `app-routing.module.ts`와 `app.module.ts`가 있으며, 컴포넌트는 `app.component.html`, `app.component.scss`, `app.component.ts`, `app.component.spec.ts`가 있다.

### 구성 요소 생성 방법

| 생성할 구성 요소 | 명령어                                |
| :--------------: | :------------------------------------ |
|     컴포넌트     | ng generate component  |
  |     디렉티브     | ng generate directive  |
  |      서비스      | ng generate service      |
  |       모듈       | ng generate module         |

  혹은 Angular Schematics Extension을 설치 한 후, 폴더에서 마우스 우클릭을 해서 component, service, module 등을 만들 수 있다.

  
    
      생성
  

  ### NgModule(Module)

  NgModule은 Angular에서 가장 중요한 구성 요소로 관련 있는 다른 요소를 묶는 역할을 한다. NgModule에는 사용할 컴포넌트나 서비스 프로바이더 등이 포함할 수 있으며, 외부로 공개(공유)할 지 아니면 다른 곳에서 해당 NgModule로 가져와 사용할 지 등을 정할 수 있다.

  모든 Angular 프로젝트에는 **반드시 하나 이상의 모듈이 존재**하며, 그 중 보통 AppModule (`app.module.ts`)이 단 하나의 최상위 모듈이다. 프로젝트 규모가 작으면 AppModule 하나만 있는 경우도 있다. React의 `App.js`와 비슷하다.

  src/app/app.module.ts

  ```ts
  import { NgModule } from '@angular/core'
  import { BrowserModule } from '@angular/platform-browser'

  import { AppRoutingModule } from './app-routing.module' // routing 설치 시 생성
  import { AppComponent } from './app.component'

  @NgModule({
    declarations: [AppComponent],
    imports: [BrowserModule, AppRoutingModule],
    providers: [],
    bootstrap: [AppComponent],
  })
  export class AppModule {}
  ```

  새로 생성된 컴포넌트는 하나의 NgModule에서 불러와야 사용할 수 있다.

  - **declarations**: 해당 모듈에 포함될 구성요소(컴포넌트나 디렉티브, 파이프)의 리스트를 선언한다.
  - **exports**: 해당 모듈의 컴포넌트나 디렉티브을 다른 모듈에서 사용하고 싶을 때 작성. AppModule(최상위 모듈)에는 존재하지 않는다.
  - **imports**: FormsModule, AppRoutingModule 등과 같은 외부 모듈(혹은 라이브러리)을 사용하고 싶을 때 추가한다. 외부 모듈은 앵귤러 모듈일수도 있고, 사용자가 정의한 모듈일수도 있다.
  - **providers**: 모듈 내에 생성된 서비스 프로바이더를 작성한다. injector가 여기에서 서비스의 존재를 알아 차릴 수 있다.
  - **bootstrap**: 프로젝트의 진입점으로 최상위 컴포넌트(일반적으로 app.module.ts)에만 작성한다.

  

  ### Component

  AppComponent를 보면 네 개의 파일이 존재한다.

  - app.component.html: HTML 템플릿 파일
  - app.component.scss: SCSS 파일 (기본은 CSS 파일)
  - app.component.ts: 컴포넌트 파일 (TypeScript)
  - app.component.spec.ts: 테스트 파일

  src/app/app.component.ts

  ```ts
  import { Component } from '@angular/core'

  @Component({
    selector: 'app-root',
    templateUrl: './app.component.html',
    styleUrls: ['./app.component.scss'],
  })
  export class AppComponent {
    title = 'rxjs-angular' // 처음에 설정한 프로젝트명이 title의 기본값으로 설정
    // 컴포넌트 클래스 영역
  }
  ```

  @Component 데코레이터에는 메타데이터 객체를 인자로 전달하며, 컴포넌트 생성에 필요한 정보를 담고 있다.

  - **selector**: HTML 템플릿의 이름이며, 다른 템플릿에서 ``으로 import 할 수 있다.
  - **templateUrl**: 해당 컴포넌트의 HTML 템플릿과 매핑한다.
  - **styleUrls**: 해당 컴포넌트의 스타일 파일과 매핑한다.

  혹은 HTML 템플릿과 CSS를 따로 파일로 만들지 않고, template, styles를 이용해 ts 파일에 바로 만들 수도 있다.

  ```ts
  import { Component } from '@angular/core'

  @Component({
    selector: 'app-root',
    template: `
    {{ title }}
  `,
    styles: [
    `
      h1 {
        color: red;
      }
    `,
    ],
  })
  export class AppComponent {
    title = 'Angular 구조 및 사용법' // 제목 변경
    // 컴포넌트 클래스 영역
  }
  ```

  컴포넌트 클래스 영역은 해당 컴포넌트 뷰를 관리하기 위한 로직을 담은 클래스를 정의한다. 여기에는 프로퍼티, 메서드 그리고 input/output 이벤트와 ngOnInit, ngOnDestroy 등과 같은 라이프싸이클 메서드를 작성할 수 있다. 라이프싸이클은 아래에서 다시 살펴보도록 하자.

  

  ### Service

  서비스는 주로 쿠키나 스토리지, 채널톡, 카카오톡 상담, 모달 등 어느 컴포넌트에서든 사용할 수 있는 공통 로직을 작성한다.

  ```ts
  @Injectable()
  export class ExampleService {
    // ...
  }
  ```

  그리고 @Injectable 데코레이터틀 작성하여 데이터 공유 클래스와 비즈니스 로직으로 동시에 사용이 가능하다.

  

  ### Directive

  Angular가 제공하는 디렉티브는 크게 어트리뷰트 디렉티브(Attribute Directive)와 구조 디렉티브(Structural Directive)로 나뉜다.

  디렉티브는 DOM의 모든 것을 직접 관리할 수 있다. HTML 요소 또는 어트리뷰트의 형태로 사용하여 디렉티브가 사용된 요소에게 무언가를 하라는 지시(directive)를 전달한다. 디렉티브는 프로젝트 전역에서 사용할 수 있는 공통 관심사를 컴포넌트에서 분리한 것으로 구현하여 컴포넌트의 복잡도를 낮추고 가독성을 향상시킨다.

  #### 어트리뷰트 디렉티브

  - NgClass: CSS 클래스 추가/제거
  - NgStyle: HTML 스타일 추가/제거
  - NgModel: HTML 폼 요소에 양방향 데이터 바인딩 추가

  #### 구조 디렉티브

  - NgIf: 조건에 따라 DOM에 추가/제거
  - NgFor: 배열 항목마다 DOM에 추가
  - NgSwitch: 조건에 맞는 것을 선택해서 DOM에 추가

  

  기본으로 내장되어 있는 것 외, 사용자가 직접 만들어 쓸 수도 있다. 글자의 색상을 파란색으로 바꾸는 디렉티브를 만들어보자.

  ```shell
  # 명령어 실행 후, 자동으로 app.module.ts의 declarations에 추가 됨
  $ ng generate directive blueText
  ```

  src/app/shared/blue-text.directive.ts

  ```ts
  import { Directive, ElementRef } from '@angular/core'

  @Directive({
    selector: '[blueText]',
  })
  export class BlueTextDirective {
    constructor(el: ElementRef) {
    el.nativeElement.style.color = 'blue'
  }
  }
  ```

  ```html
  {{ title }}

  blue title: {{ title }}
  ```

  
    
  

  잘 적용되었다면 위처럼 파란색으로 바뀐 것을 알 수 있다.

  

  ### Pipe

  파이프(pipe)는 템플릿에서 사용되며, 화면에 표시하는 형식만 변경하고 싶을 때 사용한다.

  ```shell
  $ ng generate component components/pipe
  ```

  src/app/components/pipe/pipe.component.ts

  ```ts
  import { Component, OnInit } from '@angular/core'

  @Component({
    selector: 'app-pipe',
    templateUrl: './pipe.component.html',
    styleUrls: ['./pipe.component.scss'],
  })
  export class PipeComponent implements OnInit {
    now = new Date()

    constructor() {}

    ngOnInit(): void {}
  }
  ```

  src/app/components/pipe/pipe.component.html

  ```html
  {{ now }}
  

  {{ now | date }}
  

  {{ now | date: "y년 MM월 dd일" }}
  
  ```

  날짜 외에도, 화폐, 대소문자, 소숫점, 퍼센트, 비동기 등의 pipe가 있다.

  ```html
  {{ 'howdy-mj' | uppercase }}
  

  {{ 10000 | currency }}
  
  

  {{ 1.2345 | number: "1.2-2" }}
  
  {{ 1.2345 | number: "3.2-2" }}
  

  {{ 0.1234 | percent }}
  
  {{ 0.1234 | percent: "2.1" }}
  
  ```

  더 자세한 건 공식문서의 Pipe API List를 참고하면 된다.

  

  

  **참고**

  

    - Angular

    - Angular Architecture

  
</content:encoded>
    </item>
  
    </channel>
  </rss>
